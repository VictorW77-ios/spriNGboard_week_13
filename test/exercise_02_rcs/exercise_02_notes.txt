Why are counter and counter_mutex being passed by reference to the threads?
--> 'counter' and 'counter_mutex' are passed by ref because we want the program to modify the containers as they're being incremented. 

How long (approximately) will it take the test to run?  Will it pass?
--> The program should run in O(3*N) time for all 3 threads, where N < num_times (num_times = 1,000) + 1ms, given the sleep() func. 

Will it pass?
--> Unsure about this! I think it will pass but I'm hesistant because the test case requires the counter == 3*num_times and I'm not sure how this'll translate with the exec running 3 threads separately at O(num_times), unless this issue is fixed by passing by reference and the counter's value ends up being 3*num_times. 

Do the outputs and times match your previous expectations?
--> Nope, but my expectations were somewhat correct. The test cases failed because the counter =/= 3*num_times. The times are interesting because the real time (0m1.077s) is higher than the user time (0m0.022s). Not to mention the sys time being 0m000s. 

Rebuild and rerun the code.  Does the test pass?
--> Yes, after implementing a lock_guard in the for loop the program runs and passes all test cases. 

How long does it take to run?
--> It takes 0m3.227s to run

Recompile and rerun the code.  Does the test pass?  
--> The program compiled but the test cases failed because the program didn't properly increment the counter (REQUIRE (counter == 3 * num_times)). 
--> I also tried commenting out the for-loop and simply initialized the lock_guard and increment operation, which compiled but failed the test case as well.  
--> The test cases also fail if the lock_guard is in scope but the counter is outside of the same scope. (real time = 0m3.274s)

How long does it take to run?  
--> The real time was 0m1.075s 

What does this say about which code should be inside critical sections?
--> The lock_guard and increment operation should be in the scope of the for-loop and are critical to the program functioning correctly. From the Sunday session and what I've read so far (cppreference - std::lock_guard), the scope really matters because when control leaves the scope of the lock_guard, the mutex is released and the lock_guard is destructed - so it's important to declare the lock_guard exactly in the scope where we need the mutex to be protected. 


